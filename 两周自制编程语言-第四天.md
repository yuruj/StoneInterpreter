## 两周自制编程语言-第四天

语言处理器在词法分析阶段将程序分割为单词后，将开始构造抽象语法树。抽象语法树是一种用于表示程序结构的树形结构。构造抽象语法树的过程称为语法分析，依然属于语言处理器的前半阶段。经过词法分析，程序已经被分解为一个个单词。语法分析的主要任务是分析单词之间的关系

语法分析的结果能同构AST来表示。这一阶段还会检查程序中是否含有语法错误

<img src="/Users/yurunjie/Library/Application Support/typora-user-images/截屏2021-04-02 下午8.59.52.png" alt="截屏2021-04-02 下午8.59.52" style="zoom:50%;" />

<img src="/Users/yurunjie/Library/Application Support/typora-user-images/截屏2021-04-02 下午9.00.02.png" alt="截屏2021-04-02 下午9.00.02" style="zoom:50%;" />

本书使用Java语言来实现语言处理器，因此选择通过对象与树形结构来表示程序结构。如果用于实现的不是面向对象语言，表示树形结构的方法也会有所不同。如果是C语言，则会使用结构体；如果是Scheme语言，则会使用列表

虽然，本书使用了对象来构造AST，但具体如何设计相关的类，也有多种不同的做法

### BNF

> 通过BNF来表示语法的例子
>
> factor:           NUMBER | "(" expression ")"
>
> term:              factor { ("*" | "/"  factor) }
>
> expression:    term { ("+" | "-") term }

要构造抽象语法树，语言处理器首先要知道将会接受哪些单词序列，并确定希望构造出怎样的抽象语法树。这由程序设计语言的语法决定

语法规定了单词的组合规则

BNF Backus-Naur Form 巴科斯范式

BNF的拓展版本 EBNF Extend BNF

BNF是 John Backus为表达Algol语言的语法而设计的，不过最后大家发现它能用于表达语言学领域中的Noam Chomsky上下文无关语法

自然语言与计算机的际会

BNF与上下文无关文法等价

<img src="/Users/yurunjie/Library/Application Support/typora-user-images/截屏2021-04-02 下午9.12.39.png" alt="截屏2021-04-02 下午9.12.39" style="zoom:50%;" />

乍一看，BNF与正则表达式区别很大，但两者的思维方式类似。BNF与正则表达式都用于表述某种模式，以检查序列的内容

BNF 无限嵌套模式

语法递归定义

在使用BNF或铁路图来表示语法后，就能借助他们进行语法分析，并构造抽象语法树。语法分析用于查找与模式匹配的单词序列。查找得到的单词序列是一个具有特定含义的单词组。分组后的单词能继续与其他单词组一起做模式匹配，组成更的分组

## 两周自制编程语言-第五天

### 设计语法分析器parser

程序已经通过词法分析器分解为了单词序列。语法分析器的任务是将这些单词序列与语法规则定义的模式进行匹配，并构造抽象语法树

### 使用解析器与组合子

接下来，我们根据之前设计的语法来设计语法分析器，如果语法规则复杂，语法分析器也会变的困难，甚至需要进行专门的理论研究。不过，之前列出的Stone语言的语法执行的语法分析比较简单。这里的语法规则由BNF写成，如果使用语法分析器自动生成工具来处理，语法分析器的设计就更加简单了。本书专门设计了一种名为Parser库的简单的库来设计语法分析器，它是一种解析器组合子类型的库

我们使用该库来设计Stone语言的语法分析器，库的内部结构及源代码则会在第17章解说

> 需要使用yacc等分析器生成器嘛？
>
> 一般都会用这类工具来生成基于BNF的语法分析器
>
> 但是难得用Java语言这样的面向对象语言范式来设计语法分析器，不如尝试下其他方式吧

Parser库的工作仅是将BNF写成的语法规则改写成Java语言程序

> 虽是从BNF形式的语法转换而来的，但这Java代码还真是混乱啊
>
> 尽管Parser库提供了内部DSL，不过要在Java内也实现内部DSL果然还是不太容易
>
> 在用Ruby设计并实现库时，即使本质上只是一段使用了库的普通的Ruby程序，也能够通过一些方式让他看起来像是用DSL写成的程序。或是让他具有和使用DSL写成的程序同样的可读性与书写复杂度。这种表面上的DSL称为内部DSL或嵌入式DSL
>
> 内部DSL只是不同的库，与外部DSL相比更容易开发。通过内部DSL写成的程序也能与没有使用DSL书写的程序混合使用
>
> 另一方面，用外部DSL写成的程序必须与普通的程序明确区分使用才行
>
> 内部DSL必须通过Ruby、Scala或是Scheme之类的语言才能实现
>
> 不过，就算是Scala，解析器组合子的内部DSL结构依然会相当混乱

## 两周自制编程语言-第六天

### 通过解释器执行程序

只要能通过语法分析得到抽象语法树，程序的执行就简单了。解释器只需从抽象语法树的根节点开始遍历该树直至叶节点，并计算各节点的内容即可。这就是解释器的基本实现原理

要根据得到的抽象语法树来执行程序，各个语法树节点对象的类都需要具备eval方法

 eval是evaluate求值的缩写。eval方法将计算与该节点为根的子树对应的语句、表达式及子表达式，并返回执行结果。因此只要调用AST的根节点对象的eval方法，就能完整执行该语法树对应的程序

eval方法的这种调用方法类似于深度优先树节点搜索算法

Stone语言这类支持变量的程序设计语言会将环境对象传递给eval方法的参数

简单来说，环境对象指的是一种用于记录变量名称与值的对应关系的数据结构，他常以哈希表的形式实现